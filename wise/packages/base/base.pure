/*
  Wise
  Copyright (C) 2010 Stephen Diehl <sdiehl@clarku.edu>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as
  published by the Free Software Foundation, either version 3 of the
  License, or (at your option) any later version.
*/

using simp;

// The default automatic simplification stack. Can be overloaded
// as desired.
using namespace simplify;

algebra_normal X = simplify_multiplication .
                   simplify_addition .
                   simplify_power .
                   simplify_rational $ X;

namespace;

/*
    Equation Manipulation
    ---------------------
*/

eq_add (eq lhs rhs) x = eq (lhs+x) (rhs+x);
eq_sub (eq lhs rhs) x = eq (lhs+(-x)) (rhs+(-x));
eq_mul (eq lhs rhs) x = eq (lhs*x) (rhs*x);
eq_div (eq lhs rhs) x = eq (lhs/x) (rhs/x);

atan2 y x = atan (rational y x) if numberp x && x > 0;
          = Pi + atan (rational y x) if all numberp [y x] && y >= 0 && x < 0;
          = -Pi + atan (rational y x ) if all numberp [y,x] && y < 0 && x < 0;
          = Pi/2 if all numberp [y,x] && y > 0 && x == 0;
          = -(Pi/2) if all numberp [y,x] && y < 0 && x == 0;
          = rational 0 0 if all numberp [y,x] && y == 0 && x == 0;
          = atan (rational y x) otherwise;

/*
    Absolute Value Manipulation
    ---------------------------
*/

expand_abs = reduce with
    abs (mul x*y) = abs(x) * abs(y);
end;

/*
    Complex Manipulation
    --------------------
*/

evals real complex x y = x;
evals real x = Re x;

evals imag complex x y = y;
evals imag x = Im x;

// Modulus
// TODO: differentiate between abs and complex modulus
abs (complex x y) = Sqrt (x^2+y^2);

conj (complex x y) = complex x (-y);
conj x = conj x;


rect_to_polar X = reduce X
with
    (complex 0 0) = 0;
    (complex x y) = (Sqrt (x*x+y*y)) * exp( I * (atan2 y x));
end;

complex_trig_expand X = reduce X
with
    Sin (complex x y)  = complex (Sin x*Cosh y) (Cos x*Sinh y);
    Cos (complex x y)  = complex (Cos x*Cosh y) (-Sin x*Sinh y);
    Tan (complex x y)  = (complex (Sin (2*x)) (Sinh (2*y))) / (Cos (2*x)+Cosh (2*y));
end;

complex_polar_to_rect X = reduce X
with
    mul r (exp (mul I theta)) = complex;
end;


complex_split (complex x y) = x + (I * y);


/* :Name: ``combine_rational`` x
   :Arguments:
   :x: Complex number
   :Description: Combines rational expressions according to the rules:
   .. math::
        -\frac{a}{b} = \frac{-a}{b}\\
        \frac{a}{b} + \frac{c}{d} = \frac{ad+bc}{bd}\\
        \frac{a}{b} \cdot \frac{c}{d} = \frac{ac}{bd}\\
        \frac{a}{b} \div \frac{c}{d} = \frac{ad}{bc}
*/

combine_rational X = reduce X
with
    // Pull the negation outside of the fraction
    -(a/b) = (-a)/b;
    (a/c) + (b/c) = (a+b)/c;
    (a/b) + (c/d) = (a*d+b*c)/(b*d);
    (a/b) / (c/d) = (a*c)/(b*d);
end;

/* :Name: ``split_rational`` x
   :Arguments:
   :x: Complex number
   :Description: Seperates rational expressions according to the rules:
   .. math::
        \frac{a+b}{c} = \frac{a}{c} + \frac{b}{c}
*/

split_rational X = reduce X
with
        (-a)/b = -(a/b);
        (a+b)/c = (a/c) + (b/c);
        (a*b)/(c*d) = (a/c)*(b/d);
end;

seperate_rational X = reduce X
with
    a/b = a*(1/b) if ~(a === 1);
end;

replace_heads f g X = replf X
with
    replf (func@_ a) = (replf func) (replf a);
    replf x = if x === f then g else x;
end;

associate_add_left = reduce with
    x+(y+z) = (x+y) + z;
end;

associate_mul_left = reduce with
    x*(y*z) = (x*y) * z;
end;

associate_add_right = reduce with
    (x+y)+z = x+(y+z);
end;

associate_mul_right = reduce with
    (x*y)*z = x*(y*z);
end;

// a+(b+(c+d))
ileft X x = iter_left (associate_add_right X) x;

iter_left (a + b) x = b + a if b === x;
iter_left (a+(b+c)) x = b + (a+c) if b === x;
iter_left (a + b) x = a + (iter_left b x);
iter_left b x = b;

pull_left X a = reduce
    (associate_add_left . associate_mul_left $ X)
with
    (y+x) = (x+y) if x === a && ~( x === y );
    (y*x) = (x*y) if x === a && ~( x === y );
    (x/y) = x*(1/y) if x === a;
    //(y/x) = (1/x)*y if x === a;
end if varp a;

pull_left X a = reduce X a with
    (y+x) = (x+y) if x === a && ~( x === y );
    (y*x) = (x*y) if x === a && ~( x === y );
    (x/y) = x*(1/y) if x === a;
    //(y/x) = (1/x)*y if x === a;
end;

pull_right X a = reduce
    (associate_add_right . associate_mul_right $ X)
with
    (y+x) = (x+y) if y === a && ~( x === y );
    (y*x) = (x*y) if y === a && ~( x === y );
    (x/y) = x*(1/y) if y === a;
    //(y/x) = (1/x)*y if y === a;
end;

pull_left_prop X prop = reduce
    (associate_add_left . associate_mul_left $ X)
with
    (y+x) = (x+y) if `(prop x) && ~( x === y );
    (y*x) = (x*y) if `(prop x) && ~( x === y );
//    (x/y) = x*(1/y) if `(prop x);
end;

pull_right_prop X prop = reduce
    (associate_add_right . associate_mul_right $ X)
with
    (y+x) = (x+y) if `(prop y) && ~( x === y );
    (y*x) = (x*y) if `(prop y) && ~( x === y );
//    (x/y) = x*(1/y) if `(prop y);
end;

pull_numeric_left X = pull_left_prop X numberp;
pull_numeric_right X = pull_right_prop X numberp;

division_theorem a b = add (mul b (a div b)) (a mod b);

//TODO: Use longs
fact n::int = loop 1 n with
  loop p n = if n>0 then loop (p*n) (n-1) else p;
end;

algebra_expand X = reduce X
with
    -(a+b)  = (-a) + (-b);
    (a+b)*k = (a * k) + (b * k);
    k*(a+b) = (k * a) + (k * b);
    (a+b)^2 = a^2+2*a*b+b^2;
end;

commute_elementary (x+y) = y+x;
commute_elementary (x-y) = (-y)+x;
commute_elementary (x*y) = y*x;
commute_elementary x = x;

nfunc f n p = nfunc (f p) (n-1) p if n > 1;
            = f p otherwise;

ntuple n p = nfunc Tuple n p;

GammaF(1/2) = Sqrt pi;
GammaF(0.5) = Sqrt pi;
