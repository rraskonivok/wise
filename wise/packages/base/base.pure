/*
  Wise
  Copyright (C) 2010 Stephen Diehl <sdiehl@clarku.edu>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as
  published by the Free Software Foundation, either version 3 of the
  License, or (at your option) any later version.
*/

// Adapted from:
//  * Cohen J S. Computer Algebra and Symbolic Computation.
//  * Scheme code at https://github.com/dharmatech

// See: Cohen J S.
cmp x y = x < y if numberp x && numberp y ;
cmp x y = 1 if numberp x && ~(numberp y) ;
cmp (a^b) (c^d) = if a === c then cmp b d else cmp a c ;
cmp a (b^c) = if a === b then cmp 1 c else cmp a b ;
cmp (a^b) c = if a === b then cmp b 1 else cmp a c ;
cmp (x1@_ y1) (x2@_ y2) = if x1===x2 then cmp y1 y2 else cmp x1 x2;
cmp (x1@_ y1) x2 = if x1===x2 then 0 else cmp x1 x2;
cmp x1 (x2@_ y2) = if x1===x2 then 1 else cmp x1 x2;
cmp x y = str x < str y if atomp x && atomp y ;
cmp x y = ~(cmp y x) otherwise ;

sump x+y = 1 ;
sump x = 0 ;

base x^y = x;
base x = x;

exponent x^y = y ;
exponent x = 1;

term (n*x) = x if numberp n ;
term ((x*y)*z) = (term (x*y)) * z ;
term (-x) = x;
term x = x ;

constant (n*x) = n if numberp n ;
constant ((x*y)*z) = (constant (x*y)) ;
constant (-x) = -1;
constant x = 1 ;

/*
    Equation Manipulation
    ---------------------
*/

eq_add (eq lhs rhs) x = eq (lhs+x) (rhs+x);
eq_sub (eq lhs rhs) x = eq (lhs+(-x)) (rhs+(-x));
eq_mul (eq lhs rhs) x = eq (lhs*x) (rhs*x);
eq_div (eq lhs rhs) x = eq (lhs/x) (rhs/x);

atan2 y x = atan (rational y x) if numberp x && x > 0;
          = Pi + atan (rational y x) if all numberp [y x] && y >= 0 && x < 0;
          = -Pi + atan (rational y x ) if all numberp [y,x] && y < 0 && x < 0;
          = Pi/2 if all numberp [y,x] && y > 0 && x == 0;
          = -(Pi/2) if all numberp [y,x] && y < 0 && x == 0;
          = rational 0 0 if all numberp [y,x] && y == 0 && x == 0;
          = atan (rational y x) otherwise;

/*
    Absolute Value Manipulation
    ---------------------------
*/

expand_abs = reduce with
    abs (mul x*y) = abs(x) * abs(y);
end;

/*
    Complex Manipulation
    --------------------
*/

evals real complex x y = x;
evals real x = Re x;

evals imag complex x y = y;
evals imag x = Im x;

// Modulus
// TODO: differentiate between abs and complex modulus
abs (complex x y) = Sqrt (x^2+y^2);

conj (complex x y) = complex x (-y);
conj x = conj x;

simplify_complex X = reduce X
with
    // Complex Addition
    (complex x y) + (complex u v) = complex (x+u) (y+v);
    - (complex x y) = complex (-x) (-y);

    // Complex Multiplication
    (complex a b) * (complex c d) = complex (a*c-b*d) (b*c+a*d);

    // Complex Division
    (complex a b) / (complex c d) = (complex ((a*c+b*d) / (c^2 + d^2)) ((b*c-a*d) / (c^2 + d^2)) )
end;

rect_to_polar X = reduce X
with
    (complex 0 0) = 0;
    (complex x y) = (Sqrt (x*x+y*y)) * exp( I * (atan2 y x));
end;

complex_trig_expand X = reduce X
with
    Sin (complex x y)  = complex (Sin x*Cosh y) (Cos x*Sinh y);
    Cos (complex x y)  = complex (Cos x*Cosh y) (-Sin x*Sinh y);
    Tan (complex x y)  = (complex (Sin (2*x)) (Sinh (2*y))) / (Cos (2*x)+Cosh (2*y));
end;

complex_polar_to_rect X = reduce X
with
    mul r (exp (mul I theta)) = complex;
end;


complex_split (complex x y) = x + (I * y);

/*
    Automatic Simplification
   -------------------------
*/

algebra_normal X = simplify_multiplication .
                   simplify_addition .
                   simplify_power .
                   simplify_rational $ X;

/* :Name: ``simplify_multiplication`` x
   :Arguments:
   :x: Arbitrary expression
   :Description: Reduces the given expression with the following rules
   .. math::
        0x = 0\\
        a^x a^y = a^{x+y}\\
        (a b^x) b^y = a b^{x+y}\\
        x(yz) = (xy)z\\
        x(-y) = (-x)y\\

   Multiplication is is associated to the left.

   Multiplication of numeric quantities is reduced to a
   single numeric quantitiy.

   Multiplication of algebraic terms is sorted alphabetically by
   variable as defined by ``cmp`` rule.
*/

simplify_multiplication = reduce
with
    0*x = 0 ;
    1*x = x ;
    x*y = (base x) ^ ((exponent x) + (exponent y)) if (base x) === (base y) ;
    a*x*y = a * ( (base x) ^ ((exponent x) + (exponent y)) ) if (base x) === (base y) ;
    x*y = y*x if cmp y x ;
    x*y*z = x*z*y if cmp z y ;
    x*(y*z) = x*y*z ;
    x*(-y) = (-x)*y ;
    -(k*x) = (-k)*x if numberp k;
end;

/* :Name: ``simplify_addition`` x
   :Arguments:
   :x: Arbitrary expression
   :Description: Reduces the given expression with the following rules
   .. math::
        0+x = x\\
        (qx)+(rx) = (q+r)(x)\\
        (qx)+(qy) = (q)(x+y)\\
        x+(y+z) = (x+y)+z\\
        -x+-y = -(x+y)\\

   Addition is is associated to the left.

   Addition of numeric quantities is reduced to a
   single numeric quantitiy.

   Addition of algebraic terms is sorted alphabetically by
   variable as defined by ``cmp`` rule.
*/

simplify_addition X = reduce X
with
    -(a*x) = (-a) * x if numberp a;
    0+x = x ;
    x+0 = x ;
    a+b = ( (constant a) + (constant b) ) * (term a) if ((term a) === (term b)) and (~numberp a && ~numberp b) ;
    a+b+c = a + ((constant b) + (constant c)) * (term b) if (term b) === (term c) ;
//    a+b = b+a if (cmp b a) && ~(sump a) ;
    a+b+c = a+c+b if cmp c b ;
    a+(b+c) = a+b+c ;
    x-x = 0;
    (-x)+x = 0;
    (-x) + (-y) = -(x+y);
end;

/* :Name: ``simplify_power`` x
   :Arguments:
   :x: Arbitrary expression
   :Description: Reduces the given expression with the following rules
   .. math::
        x^0 = 1\\
        x^1 = x\\
        0^x = 0\\
        1^x = 1\\
        (x^y)^z = x^{yz}\\
        (xy)^z = x^y x^z\\

   Powers of numeric quantities is reduced to a
   single numeric quantitiy.
*/

simplify_power = reduce
with
    0^x = 0 if `(x ~= 0);
    1^x = 1 ;
    x^0 = 1 if `(x ~= 0);
    x^1 = x ;
    (r^s)^w = r^(s*w) if numberp w ;
    (x*y)^w = (x^w)*(y^w) if numberp w ;
end;

/* :Name: ``rational_to_power`` x
   :Arguments:
   :x: Arbitrary expression
   :Description: Reduces the given expression with the following rules
   .. math::
        \frac{x}{y} = x y^{-1}\\
*/

rational_to_power = reduce with
    x/y = x*(y^(-1));
end;

/*
   Rationals
   ------------
*/

/* :Name: ``simplify_rational`` x
   :Arguments:
   :x: Arbitrary expression
   :Description: Reduces the given expression with the following rules
   .. math::
        \frac{x}{y} = x y^{-1}\\
*/

simplify_rational = reduce with
    x/x = 1;
    0/x = 0;
    x/1 = x;
    (-x)/y = -(x/y);
end;

/* :Name: ``combine_rational`` x
   :Arguments:
   :x: Complex number
   :Description: Combines rational expressions according to the rules:
   .. math::
        -\frac{a}{b} = \frac{-a}{b}\\
        \frac{a}{b} + \frac{c}{d} = \frac{ad+bc}{bd}\\
        \frac{a}{b} \cdot \frac{c}{d} = \frac{ac}{bd}\\
        \frac{a}{b} \div \frac{c}{d} = \frac{ad}{bc}
*/

combine_rational X = reduce X
with
    // Pull the negation outside of the fraction
    -(a/b) = (-a)/b;
    (a/c) + (b/c) = (a+b)/c;
    (a/b) + (c/d) = (a*d+b*c)/(b*d);
    (a/b) / (c/d) = (a*c)/(b*d);
end;

/* :Name: ``split_rational`` x
   :Arguments:
   :x: Complex number
   :Description: Seperates rational expressions according to the rules:
   .. math::
        \frac{a+b}{c} = \frac{a}{c} + \frac{b}{c}
*/

split_rational X = reduce X
with
        (-a)/b = -(a/b);
        (a+b)/c = (a/c) + (b/c);
        (a*b)/(c*d) = (a/c)*(b/d);
end;

seperate_rational X = reduce X
with
    a/b = a*(1/b) if ~(a === 1);
end;

replace_heads f g X = replf X
with
    replf (func@_ a) = (replf func) (replf a);
    replf x = if x === f then g else x;
end;

associate_add_left = reduce with
    x+(y+z) = (x+y) + z;
end;

associate_mul_left = reduce with
    x*(y*z) = (x*y) * z;
end;

associate_add_right = reduce with
    (x+y)+z = x+(y+z);
end;

associate_mul_right = reduce with
    (x*y)*z = x*(y*z);
end;

// a+(b+(c+d))
ileft X x = iter_left (associate_add_right X) x;

iter_left (a + b) x = b + a if b === x;
iter_left (a+(b+c)) x = b + (a+c) if b === x;
iter_left (a + b) x = a + (iter_left b x);
iter_left b x = b;

pull_left X a = reduce
    (associate_add_left . associate_mul_left $ X)
with
    (y+x) = (x+y) if x === a && ~( x === y );
    (y*x) = (x*y) if x === a && ~( x === y );
    (x/y) = x*(1/y) if x === a;
    //(y/x) = (1/x)*y if x === a;
end if varp a;

pull_left X a = reduce X a with
    (y+x) = (x+y) if x === a && ~( x === y );
    (y*x) = (x*y) if x === a && ~( x === y );
    (x/y) = x*(1/y) if x === a;
    //(y/x) = (1/x)*y if x === a;
end;

pull_right X a = reduce
    (associate_add_right . associate_mul_right $ X)
with
    (y+x) = (x+y) if y === a && ~( x === y );
    (y*x) = (x*y) if y === a && ~( x === y );
    (x/y) = x*(1/y) if y === a;
    //(y/x) = (1/x)*y if y === a;
end;

pull_left_prop X prop = reduce
    (associate_add_left . associate_mul_left $ X)
with
    (y+x) = (x+y) if `(prop x) && ~( x === y );
    (y*x) = (x*y) if `(prop x) && ~( x === y );
//    (x/y) = x*(1/y) if `(prop x);
end;

pull_right_prop X prop = reduce
    (associate_add_right . associate_mul_right $ X)
with
    (y+x) = (x+y) if `(prop y) && ~( x === y );
    (y*x) = (x*y) if `(prop y) && ~( x === y );
//    (x/y) = x*(1/y) if `(prop y);
end;

pull_numeric_left X = pull_left_prop X numberp;
pull_numeric_right X = pull_right_prop X numberp;

division_theorem a b = add (mul b (a div b)) (a mod b);

//TODO: Use longs
fact n::int = loop 1 n with
  loop p n = if n>0 then loop (p*n) (n-1) else p;
end;

algebra_expand X = reduce X
with
    -(a+b)  = (-a) + (-b);
    (a+b)*k = (a * k) + (b * k);
    k*(a+b) = (k * a) + (k * b);
    (a+b)^2 = a^2+2*a*b+b^2;
end;

commute_elementary (x+y) = y+x;
commute_elementary (x-y) = (-y)+x;
commute_elementary (x*y) = y*x;
commute_elementary x = x;

nfunc f n p = nfunc (f p) (n-1) p if n > 1;
            = f p otherwise;

ntuple n p = nfunc Tuple n p;

GammaF(1/2) = Sqrt pi;
GammaF(0.5) = Sqrt pi;
