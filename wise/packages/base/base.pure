/*
  Wise
  Copyright (C) 2010 Stephen Diehl <sdiehl@clarku.edu>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as
  published by the Free Software Foundation, either version 3 of the
  License, or (at your option) any later version.
*/

using system;
using simp;

nonfix Pi;    // Constant Pi
nonfix Exp1;  // Constant e
nonfix IUnit; // Constant i
nonfix Unit;  // 1
nonfix Zero;  // 0

namespace constants;
    // Declare constants with single letter names as const to
    // avoid namespace collisions.
    const E = Exp1;
    const I = I;
namespace;

//Evaluate out to the constant defined in the default math
//libraires.
evalf Pi = pi;
evalf Exp1 = e;
evalf IUnit = i;
evalf Unit = 1.0;
evalf Zero = 0.0;

// The default automatic simplification stack.
using namespace simplify;
algebra_normal X = simplify_multiplication .
                   simplify_addition .
                   simplify_power .
                   simplify_rational $ X;
namespace;

/* 
  -----------------------
  Numeric Function Values
  -----------------------
*/


using namespace constants;
    evalf (Exp 0) = 1.0;
    evalf (Exp 1) = evalf E;
    evalf (Exp (complex x y)) = Exp x with
        Exp (I * Pi) = -1;
    end;
    evalf (Exp x) = exp x if numberp x;
                  = Exp x otherwise;
namespace;

using namespace constants;
    evalf (Ln Exp1) = 1;
    evalf (Ln x) = ln x if numberp x && x ~= 0;
                 = nan if numberp x && x == 0;
                 = Ln x otherwise;
namespace;


/*
    Equation Manipulation
    ---------------------
*/

eq_add (eq lhs rhs) x = eq (lhs+x) (rhs+x);
eq_sub (eq lhs rhs) x = eq (lhs+(-x)) (rhs+(-x));
eq_mul (eq lhs rhs) x = eq (lhs*x) (rhs*x);
eq_div (eq lhs rhs) x = eq (lhs/x) (rhs/x);

/*
    Complex Numbers
    --------------------
*/

evals real complex x y = x;
evals real x = Re x;
evals imag complex x y = y;
evals imag x = Im x;

/*__show__ (complex x y) = sprintf "%s + i %s" (str x, str y) if all atomp [x,y];*/
                       /*= sprintf "(%s) + i(%y)" (str x, str y) otherwise;*/

// Modulus
/*abs (complex x y) = Sqrt (x^2+y^2);*/
/*conj (complex x y) = complex x (-y);*/
/*conj x = conj x;*/

rect_to_polar = reduce with
    (complex 0 0) = 0;
    (complex x y) = (Sqrt (x*x+y*y)) * exp( I * (atan2 y x));
end;

complex_trig_expand = reduce with
    Sin (complex x y)  = complex (Sin x*Cosh y) (Cos x*Sinh y);
    Cos (complex x y)  = complex (Cos x*Cosh y) (-Sin x*Sinh y);
    Tan (complex x y)  = (complex (Sin (2*x)) (Sinh (2*y))) / (Cos (2*x)+Cosh (2*y));
end;

complex_polar_to_rect = reduce with
    mul r (exp (mul I theta)) = complex;
end;

complex_split (complex x y) = x + (I * y);

/* 
    Combine rational quantities by the rules:
    -\frac{a}{b} = \frac{-a}{b}
    \frac{a}{b} + \frac{c}{d} = \frac{ad+bc}{bd}
    \frac{a}{b} \cdot \frac{c}{d} = \frac{ac}{bd}
    \frac{a}{b} \div \frac{c}{d} = \frac{ad}{bc}
*/

combine_rational X = reduce X
with
    -(a/b) = (-a)/b;
    (a/c) + (b/c) = (a+b)/c;
    (a/b) + (c/d) = (a*d+b*c)/(b*d);
    (a/b) / (c/d) = (a*c)/(b*d);
end;

/* 
  ----------------------
   Rational Manipulation
  ----------------------
*/

// Convert numerical primitives to rational types.
to_rational X::int = rational X;
to_rational X::double = rational X;
to_rational X::bigint = rational X;
to_rational x = x/1;

split_rational X = reduce X
with
        (-a)/b = -(a/b);
        (a+b)/c = (a/c) + (b/c);
        (a*b)/(c*d) = (a/c)*(b/d);
end;

seperate_rational X = reduce X
with
    a/b = a*(1/b) if ~(a === 1);
end;

/* 
  ----------------------------------
  Commutative Variable Manipulation
  ----------------------------------
*/

commute_elementary (x+y) = y+x;
commute_elementary (x-y) = (-y)+x;
commute_elementary (x*y) = y*x;
commute_elementary x = x;

associate_add_left = reduce with
    x+(y+z) = (x+y) + z;
end;

associate_mul_left = reduce with
    x*(y*z) = (x*y) * z;
end;

associate_add_right = reduce with
    (x+y)+z = x+(y+z);
end;

associate_mul_right = reduce with
    (x*y)*z = x*(y*z);
end;

// a+(b+(c+d))
ileft X x = iter_left (associate_add_right X) x;

iter_left (a + b) x = b + a if b === x;
iter_left (a+(b+c)) x = b + (a+c) if b === x;
iter_left (a + b) x = a + (iter_left b x);
iter_left b x = b;

pull_left X a = reduce
    (associate_add_left . associate_mul_left $ X)
with
    (y+x) = (x+y) if x === a && ~( x === y );
    (y*x) = (x*y) if x === a && ~( x === y );
    (x/y) = x*(1/y) if x === a;
    //(y/x) = (1/x)*y if x === a;
end if varp a;

pull_left X a = reduce X a with
    (y+x) = (x+y) if x === a && ~( x === y );
    (y*x) = (x*y) if x === a && ~( x === y );
    (x/y) = x*(1/y) if x === a;
    //(y/x) = (1/x)*y if x === a;
end;

pull_right X a = reduce
    (associate_add_right . associate_mul_right $ X)
with
    (y+x) = (x+y) if y === a && ~( x === y );
    (y*x) = (x*y) if y === a && ~( x === y );
    (x/y) = x*(1/y) if y === a;
    //(y/x) = (1/x)*y if y === a;
end;

pull_left_prop X prop = reduce
    (associate_add_left . associate_mul_left $ X)
with
    (y+x) = (x+y) if `(prop x) && ~( x === y );
    (y*x) = (x*y) if `(prop x) && ~( x === y );
//    (x/y) = x*(1/y) if `(prop x);
end;

pull_right_prop X prop = reduce
    (associate_add_right . associate_mul_right $ X)
with
    (y+x) = (x+y) if `(prop y) && ~( x === y );
    (y*x) = (x*y) if `(prop y) && ~( x === y );
//    (x/y) = x*(1/y) if `(prop y);
end;

pull_numeric_left X = pull_left_prop X numberp;
pull_numeric_right X = pull_right_prop X numberp;

algebra_expand X = reduce X
with
    -(a+b)  = (-a) + (-b);
    (a+b)*k = (a * k) + (b * k);
    k*(a+b) = (k * a) + (k * b);
    (a+b)^2 = a^2+2*a*b+b^2;
end;

/*
    ----
    Misc
    ----
*/

// Factorial function via accumulator outputs a bigint;
evalf (fact n) = loop 1 (bigint n) with
  loop p n = if n>0 then loop (p*n) (n-1) else p;
end;

/*__show__ (fact x) = sprintf "%s!" (str x) if atomp x;*/
                  /*= sprintf "(%s)!" (str x) otherwise;*/

nfunc f n p = nfunc (f p) (n-1) p if n > 1;
            = f p otherwise;

ntuple n p = nfunc Tuple n p;

GammaF(1/2) = Sqrt pi;
GammaF(0.5) = Sqrt pi;

expand_abs = reduce with
    abs (mul x*y) = abs(x) * abs(y);
end;

division_theorem a b = add (mul b (a div b)) (a mod b);
