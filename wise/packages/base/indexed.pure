/* 
  ----------------
  Indexed Objects
  ----------------
*/

// Inner product
infixl 1000 <*>; // Matrix product
infixl 1000 <+>; // Matrix addition
infixl 1000 <'>; // Matrix transpose
infixl 1000 <.>; // Matrix transpose

prefix 1000 expandindex;

const ph;

// Convert a n-tuple into a (n+1)-tuple
expand_tuple (Tuple xs) = Tuple $ xs+[ph] ;
// Convert a n-tuple into a (n-1)-tuple
contract_tuple (Tuple xs) = Tuple $ xs !! (0..#xs-2);

nrows x::matrix = (dim x) ! 0;
ncols x::matrix = (dim x) ! 1;

// Convert a n-vector into a (n+1)-vector
/*incrows mat = pack $ {*/
    /*if (i > nrows mat) || (j > ncols mat) then*/
        /*1*/
    /*else*/
        /*mat ! (i-1,j-1)*/
    /*| i=(1..nrows mat); j=(1..ncols mat + 1) };*/

/*inccols mat = pack $ {*/
    /*if (i > nrows mat) || (j > ncols mat) then*/
        /*1*/
    /*else*/
        /*mat ! (i-1,j-1)*/
    /*| i=(1..nrows mat + 1); j=(1..ncols mat) };*/

inccols mat = matrix $ map ((+[ph]) . list) $ rows mat;
incrows mat = transpose $ matrix $ map ((+[ph]) . list) $ cols mat;

// Convert a n-vector into a (n-1)-vector
contract_vector (Vector xs) = Vector $ xs !! (0..#xs-2);

evals (Vector xs) + (Vector ys) = Vector $ zipwith (+) xs ys;
evals k * (Vector xs) = Vector $ map (k*) xs;
evals (Vector xs) * k = Vector $ map (k*) xs;

sum = foldl (+) 0;

dot x::matrix y::matrix = sum $ zipwith (*) (rowvector x) (rowvector y);

// Matrix Addition
(<+>) x::matrix y::matrix =  zipwith (+) x y if dim x == dim y;

// Matrix multiplication
/*(<*>) x::matrix y::matrix = sum $ zipwith (*) (rowvector x) (rowvector y) if ncols x == nrows y;*/
(<*>) x::matrix y::matrix = {dot u v | u = rows x; v = cols y};

// Scalar multiplication
(<.>) a x::matrix = map (a*) x if ~matrixp a;

evals (x::matrix + y::matrix) = x <+> y if dim x == dim y;
evals (x::matrix * y::matrix) = x <*> y if dim x == dim y;
evals (k * x::matrix) = k <.> x;
evals (x::matrix * k) = k <.> x;

// Constructors
RowVector = rowvector;
ColVector = colvector;

// nxn identity matrix
eye n = {i==j | i = 1..n; j = 1..n};

// nxn zero matrix
zeros n = {0 | i = 1..n; j = 1..n};

phmat n = {ph | i = 1..n; j = 1..n};

tensor_type x::double |
tensor_type x::int = (0,0) if numberp x;
tensor_type x::matrix = (0,1) if vectorp x;
                      = (1,1) if matrixp x;

Summmation f (x:xs) (b:bs) = 0;

evals Sum (x:xs) = sum $ x:xs;

TSum f x = Tensor (indices f) x;


// Return the indices of the tensor, repeated indices imply
// summation and are summed over.

indices (Tensor x:xs) = set $x:xs;
/*
  ----------------------
  Commutative Operations
  ----------------------
*/

commute_indexed (a <+> b) = b <+> a;
commute_indexed (a <*> b) = -(b <*> a);
commute_indexed (-(a <*> b)) = b <*> a;

Diag xs = diagmat xs;

evals LeviCivita i j k = int $ (j-i)*(k-i)*(k-j)/2;

KroneckerDelta i j = 0 if i ~= j;
                   = 1 if i == j;
