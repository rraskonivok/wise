/* 
  ----------------
  Indexed Objects
  ----------------
*/

// Inner product
infixl 1000 <*>; // Matrix product
infixl 1000 <+>; // Matrix addition
infixl 1000 <'>; // Matrix transpose
infixl 1000 <.>; // Matrix transpose

prefix 1000 expandindex;
prefix 1000 Idx;

// Convert a n-tuple into a (n+1)-tuple
expand_tuple (Tuple xs) = Tuple $ xs+[ph] ;
// Convert a n-tuple into a (n-1)-tuple
contract_tuple (Tuple xs) = Tuple $ xs !! (0..#xs-2);

nrows x::matrix = (dim x) ! 0;
ncols x::matrix = (dim x) ! 1;

inccols mat::matrix = matrix $ map ((+[ph]) . list) $ rows mat;
incrows mat::matrix = transpose $ matrix $ map ((+[ph]) . list) $ cols mat;

// Generic expansion functions
fstex (f@_ x y) = f (x+[ph]) y if listp x;
fstex (f@_ x) = f (x+[ph]) if listp x;
sndex (f@_ x y) = f x (y+[ph]) if listp y;

incrows (f@_ x y) = f (x+[ph]) y if listp x;

// Convert a n-vector into a (n-1)-vector
contract_vector (Vector xs) = Vector $ xs !! (0..#xs-2);

evals (Vector xs) + (Vector ys) = Vector $ zipwith (+) xs ys;
evals k * (Vector xs) = Vector $ map (k*) xs;
evals (Vector xs) * k = Vector $ map (k*) xs;

sum = foldl (+) 0;

dot x::matrix y::matrix = sum $ zipwith (*) (rowvector x) (rowvector y);

// Matrix Addition
(<+>) x::matrix y::matrix =  zipwith (+) x y if dim x == dim y;

// Matrix multiplication
/*(<*>) x::matrix y::matrix = sum $ zipwith (*) (rowvector x) (rowvector y) if ncols x == nrows y;*/
(<*>) x::matrix y::matrix = {dot u v | u = rows x; v = cols y};

// Scalar multiplication
(<.>) a x::matrix = map (a*) x if ~matrixp a;

evals (x::matrix + y::matrix) = x <+> y if dim x == dim y;
evals (x::matrix * y::matrix) = x <*> y if ncols x == nrows y;

evals (k * x::matrix) = k <.> x if numberp k || varp k;
evals (x::matrix * k) = k <.> x if numberp k || varp k;

// Constructors
RowVector = rowvector;
ColVector = colvector;

/*
  ----------------------
  Special Matrices
  ----------------------
*/

eye n = {i==j | i = 1..n; j = 1..n};
zeros n = {0 | i = 1..n; j = 1..n};
phmat n = {ph | i = 1..n; j = 1..n};
cstmat n c = {c | i = 1..n; j = 1..n};

Transpose x::matrix = transpose x;

Summmation f (x:xs) (b:bs) = 0;

evals Sum (x:xs) = sum $ x:xs;

lex a b = str a < str b;
lexo xs = sort lex xs;

/*
  ----------------------
  Abstract Tensors
  ----------------------
*/

ATensor x co cv = Tensor x (Idx lexo co) (Idx lexo cv);

tensor_type x::double |
tensor_type x::int = (0,0) if numberp x;
tensor_type x::matrix = (0,1) if vectorp x;
                      = (1,1) if matrixp x;
tensor_type (Tensor (Idx co) (Idx cv)) = (#co,#cv);

addcoi (Tensor x (Idx co) (Idx cv)) = (Tensor x (Idx co + [ph]) (Idx cv));
addcoi x = x;

addcvi (Tensor x (Idx co) (Idx cv)) = (Tensor x (Idx co ) (Idx cv + [ph]));
addcvi x = x;

indices (Tensor (Idx co) (Idx cv)) = co,cv;

evals (Tensor x (Idx co1) (Idx cv1)) * 
      (Tensor y (Idx co2) (Idx cv2)) = 
      (Tensor (x*y) (Idx co1 + co2) (Idx cv1 + cv2));

evals (Tensor x (Idx co1) (Idx cv1)) * 
      (Tensor y (Idx co2) (Idx cv2)) = 
      (Tensor (x*y) (Idx co1 + co2) (Idx cv1 + cv2));

/*
  ----------------------
  Special Tensors
  ----------------------
*/

LeviCevita = ATensor epsilon [];

Diag xs = diagmat $ rowvector xs;

evals LeviCivita i j k = int $ (j-i)*(k-i)*(k-j)/2;

KroneckerDelta i j = 0 if i ~= j;
                   = 1 if i == j;
