namespace poly;
infixl 6 $+ ; // Addition
infixl 6 $- ; // Subtraction
infixl 7 $* ; // Multiplication
infixl 7 $. ; // Scalar Multiplication
infixl 6 $/ ; // Division
infixl 6 $# ; // Composition

// Addition of power series
(a:as) $+ (b:bs) = (a+b) : (as $+ bs);
as     $+ []     = as;
[]     $+ bs     = bs;

// Subtraction of power serie
as $- bs = as $+ (map neg bs);

// Scalar multiplication of power series
a $. bs = map (a*) bs;

// Append 0 term to power series
shift [] = [];
shift as = 0 : as;

// Multiplication of power series
[] $* _ = [];
_ $* [] = [];
(a:as) $* (b:bs) = [a*b] $+
    shift (map (a*) bs $+
    map (*b) as) $+
    shift (shift (as $* bs));

series f = f : repeat 0;
[] $/ _ = [];

(f:ft) $/ (g:gt) = qs : series(1/g) $. (ft $- (qs $. gt)) 
    with qs = f/g end;

[] $# gs = [];
(f:ft) $# (gs@(0:gt)) = f : ( gt $* (ft $# gs) );
namespace;

using namespace poly;
expr_to_poly X var = _to_poly X with
    _to_poly (x+y) = (_to_poly x) $+ (_to_poly y);
    _to_poly (x*y) = (_to_poly x) $* (_to_poly y);
    _to_poly (x^0) = (_to_poly x);
    _to_poly (x^(y::int)) = (_to_poly x) $* (_to_poly $ x^(y-1));

    _to_poly x = [0,1] if x === var;
    _to_poly x = [x] if numberp x;
    _to_poly x = throw ("Unknown variable: " + str(x)) if varp x;
end;
namespace;

series_eval x xs = foldl1 (+) $ zipwith (*) xs [x^n | n=(0..(#xs))];

poly_to_expr = series_eval;

/*using namespace poly;*/
/*[] / gs = [];*/
/*(0:fs) / (0:gs) = fs / gs;*/
/*(_:fs) / (0:gs) = error "division by 0 attempted";*/
/*(f:fs) / (g:gs) = (f/g) : ((fs $- (f/g) $. gs) / (g:gs) &);*/
/*(f:fs) / (g:gs) = (f/g) : (fs $- ( (f/g) $. gs )) / (g:gs);*/
/*namespace;*/
