// This a fork of the Pure math standard library written by
// Albert Graef and released under the LGPL license. See original
// source code at:
// http://pure-lang.googlecode.com/svn/trunk/pure/lib/math.pure

// -- Original License --

/* The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

// Note: This library cannot be used to replace the standard math.pure.
const MATHS_VERSION = 0.1;

// Random number generation
extern int genrand_int32() = random;
extern int genrand_int31() = random31;
extern double genrand_res53() = random53;
extern void init_genrand(int) = srandom;
extern void init_genrand_array(int*, int) = srandom_array;

srandom x::matrix = srandom_array x (#x) if imatrixp x && dim x!0 == 1;

extern double sqrt(double);

sqrt x::int | sqrt x::bigint = sqrt (double x);

/* Exponential function and logarithms. */
extern double exp(double);
namespace __C;
extern double log(double);
namespace;

ln x::double = __C::log x;
log x::double = __C::log x/__C::log 10.0;

exp x::int | exp x::bigint = exp (double x);
ln x::int | ln x::bigint = ln (double x);
log x::int | log x::bigint = log (double x);

/* Gamma function */
extern double tgamma(double), double lgamma(double);
tgamma x::int = tgamma (double x);
lgamma x::int = lgamma (double x);

/* Error function */
extern double erf(double);
extern double erfc(double);

/* Trigonometric functions. */
extern double sin(double), double cos(double), double tan(double);
extern double asin(double), double acos(double), double atan(double);
extern double atan2(double,double);

namespace nconstants;
    // Eulerâ€“Mascheroni constant
    const euler = 0.57721566490153286060651209008240243104;

    // Euler's number
    const e = exp 1.0;

    // The imaginary unit.
    const i = 0+:1;

    // Ludolph's number.
    const pi = 4.0*atan 1.0;
namespace;

sin x::int | sin x::bigint = sin (double x);
cos x::int | cos x::bigint = cos (double x);
tan x::int | tan x::bigint = tan (double x);

asin x::int | asin x::bigint = asin (double x);
acos x::int | acos x::bigint = acos (double x);
atan x::int | atan x::bigint = atan (double x);

atan2 x::int y::int | atan2 x::bigint y::bigint |
atan2 x::bigint y::int | atan2 x::int y::bigint = atan2 (double x) (double y);
atan2 x::int y::double | atan2 x::bigint y::double = atan2 (double x) y;
atan2 x::double y::int | atan2 x::double y::bigint = atan2 x (double y);

/* Hyperbolic functions. */
extern double sinh(double), double cosh(double), double tanh(double);
extern double __asinh(double) = asinh, double __acosh(double) = acosh,
  double __atanh(double) = atanh;

sinh x::int | sinh x::bigint = sinh (double x);
cosh x::int | cosh x::bigint = cosh (double x);
tanh x::int | tanh x::bigint = tanh (double x);
asinh x::int | asinh x::bigint = asinh (double x);
acosh x::int | acosh x::bigint = acosh (double x);
atanh x::int | atanh x::bigint = atanh (double x);

/*
  -------------------------
  Exact Rational Arithmetic
  -------------------------
*/

// fall back to ordinary inexact division in all other cases
x::double%y		= x/y if numberp y;
x%y::double		= x/y if numberp x;

/* Exact rational arithmetic */
rational x@(_%_)	= x;
rational x::int		|
rational x::bigint	= x%1;

namespace __C;
extern expr* pure_rational(double);
namespace;
rational x::double	= n%d when n,d = __C::pure_rational x end;

int x@(_%_)    = int (bigint x);
bigint x@(_%_) = trunc x;
double (x%y)   = x/y;

complex (x%y) = x%y +: 0L%1L;
rect (x%y)    = x%y +: 0L%1L;
polar (x%y)   = x%y <: 0L%1L;

num (x%y)	= x;
den (x%y)	= y;

num x::int	    |
num x::bigint	= bigint x;
num x::double	= if frac x==0.0 then bigint x else num (rational x);

den x::int	    |
den x::bigint	= 1L;
den x::double	= if frac x==0.0 then 1L else den (rational x);

/*
  ----------------------
  Signs
  ----------------------
*/

abs (x%y)	= abs x % y;
sgn (x%y)	= sgn x;

/*
  ----------------------
  Complex Functions
  ----------------------
*/

arg (x%y)    = atan2 0 (x/y);
re x@(_%_)   = x;
im (_%_)     = 0L%1L;
conj x@(_%_) = x;

/*
  ----------------------
  Rounding
  ----------------------
*/


floor x@(_%_)	= if n<=x then n else n-1 when n::bigint = trunc x end;
ceil x@(_%_)	= -floor (-x);
round (x%y)	    = -round ((-x)%y) if x<0;
                = x div 2 + 1     if y==2;
                = (2*x+y) div (2*y) otherwise;
trunc (x%y)	    = x div y;
frac x@(_%_)	= x-trunc x;

/*
  ----------------------
  Exponentiation
  ----------------------
*/


/* The pow function. Returns exact powers of integers and rationals for all
   integer exponents. */

pow (x%y) n::int	|
pow (x%y) n::bigint	= pow x n % pow y n if n>0;
                    = pow y (-n) % pow x (-n) if n<0;
                    = 1L%1L otherwise;

// Negative powers of integers.
pow x::int n::int	    |
pow x::int n::bigint	|
pow x::bigint n::int	|
pow x::bigint n::bigint	= 1 % pow x (-n) if n<0;

/*
  ----------------------
  Inexact Fallbacks
  ----------------------
*/

sqrt (x%y)	= sqrt (x/y);

exp (x%y)	= exp (x/y);
ln (x%y)	= ln (x/y);
log (x%y)	= log (x/y);

sin (x%y)	= sin (x/y);
cos (x%y)	= cos (x/y);
tan (x%y)	= tan (x/y);
asin (x%y)	= asin (x/y);
acos (x%y)	= acos (x/y);
atan (x%y)	= atan (x/y);

atan2 (x%y) z	= atan2 (x/y) z if realp z;
atan2 x (y%z)	= atan2 x (y/z) if realp x;

sinh (x%y)	= sinh (x/y);
cosh (x%y)	= cosh (x/y);
tanh (x%y)	= tanh (x/y);
asinh (x%y)	= asinh (x/y);
acosh (x%y)	= acosh (x/y);
atanh (x%y)	= atanh (x/y);

/*
  -----------------------
  Comparisons
  -----------------------
*/
x1%y1 == x2%y2	= x1*y2 == x2*y1;
x1%y1 ~= x2%y2	= x1*y2 ~= x2*y1;
x1%y1 <  x2%y2	= x1*y2 <  x2*y1;
x1%y1 <= x2%y2	= x1*y2 <= x2*y1;
x1%y1 >  x2%y2	= x1*y2 >  x2*y1;
x1%y1 >= x2%y2	= x1*y2 >= x2*y1;

x1%y1 == x2	= x1 == x2*y1 if numberp x2;
x1%y1 ~= x2	= x1 ~= x2*y1 if numberp x2;
x1%y1 <  x2	= x1 <  x2*y1 if realp x2;
x1%y1 <= x2	= x1 <= x2*y1 if realp x2;
x1%y1 >  x2	= x1 >  x2*y1 if realp x2;
x1%y1 >= x2	= x1 >= x2*y1 if realp x2;

x1 == x2%y2	= x1*y2 == x2 if numberp x2;
x1 ~= x2%y2	= x1*y2 ~= x2 if numberp x2;
x1 <  x2%y2	= x1*y2 <  x2 if realp x2;
x1 <= x2%y2	= x1*y2 <= x2 if realp x2;
x1 >  x2%y2	= x1*y2 >  x2 if realp x2;
x1 >= x2%y2	= x1*y2 >= x2 if realp x2;

/*
  -----------------------
  Type Tags
  -----------------------
*/

compvalp    x = numberp x;
realvalp    x = compvalp x && im x==0;
ratvalp     x = realvalp x && re (x-x)~==nan;
bigintvalp  x = ratvalp x && den (re x)==1;
intvalp     x = bigintvalp x && int (re x)==x;

type compval 	= compvalp;
type realval 	= realvalp;
type ratval 	= ratvalp;
type bigintval 	= bigintvalp;
type intval 	= intvalp;
