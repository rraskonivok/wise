/*
  Wise
  Copyright (C) 2010 Stephen Diehl <sdiehl@clarku.edu>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as
  published by the Free Software Foundation, either version 3 of the
  License, or (at your option) any later version.
*/

// References:
//  * Cohen J S. Computer Algebra and Symbolic Computation.
//  * Scheme code at https://github.com/dharmatech

namespace simplify;

simplify_complex X = reduce X
with
    // Complex Addition
    (complex x y) + (complex u v) = complex (x+u) (y+v);
    - (complex x y) = complex (-x) (-y);

    // Complex Multiplication
    (complex a b) * (complex c d) = complex (a*c-b*d) (b*c+a*d);

    // Complex Division
    (complex a b) / (complex c d) = (complex ((a*c+b*d) / (c^2 + d^2)) ((b*c-a*d) / (c^2 + d^2)) )
end;

/*
    Automatic Simplification
   -------------------------
*/

rational_to_power = reduce with
    x/y = x*(y^(-1));
end;

rat_simp = reduce with
    1/(1/x) = x;
    0/x = 0;
    x/1 = x;
    x/(y/z) = (x*z)/y;
end;

// Reduce simple expressions involving 1 and 0
basic_simplify = reduce with
    x % y = 0 if numberp x && x == 0;
    x % y = x if numberp y && y == 1;
    x * y = 0 if (numberp x && x == 0) ||
                 (numberp y && y == 0);

    x * y = x if isone y;
    x * y = y if isone x;
    x * y = -x if isnegone y;
    x * y = -y if isnegone x;

    x + y = x if iszero y;
    x + y = y if iszero x;

    0^x = 0 if numberp x;
    x^0 = 1;
    x^1 = x;
    -(-x) = x;
    Sin 0 = 0;
    Cos 0 = 1;
    Exp 0 = 1;
end;

// Propogate an operator through an expression by applying it to
// the leaves of the expression tree and recursively upwards.
// At the moment only propogate through n={0,1,2,3} n-ary expressions.
propogate_thru rule expr = _rule (expr) with
    _rule (f@_ x y z) = rule $ f (_rule x) (_rule y) (_rule z) if ~(f === _rule);
    _rule (f@_ x y) = rule $ f (_rule x) (_rule y) if ~(f === _rule);
    _rule (f@_ x) = rule $ f (_rule x) if ~(f === _rule);
    _rule x = rule x;
end;

recursive_evalf = propogate_thru (evalf);

namespace;

// -------------------------------
// Term Properties
// -------------------------------

sump (x+y) = 1 ; sump x = 0 ;
base (x^y) = x ;
base x = x ;
exponent (x^y) = y ;
exponent x = 1 ;

term (-n*x) = x if numberp n;
term (n*x) = x if numberp n ;
term ((x*y)*z) = (term (x*y)) * z ;
term x = x ;

constant (-n*x) = -n if numberp n;
constant (n*x) = n if numberp n ;
constant ((x*y)*z) = (constant (x*y)) ;
constant (-x) = -1;
constant x = 1 ;

cmp x y = x < y if numberp x && numberp y ;
cmp x y = 1 if numberp x && ~(numberp y) ;
cmp (a^b) (c^d) = if a === c then cmp b d else cmp a c ;
cmp a (b^c) = if a === b then cmp 1 c else cmp a b ;
cmp (a^b) c = if a === b then cmp b 1 else cmp a c ;
cmp (x1@_ y1) (x2@_ y2) = if x1===x2 then cmp y1 y2 else cmp x1 x2;
cmp (x1@_ y1) x2 = if x1===x2 then 0 else cmp x1 x2;
cmp x1 (x2@_ y2) = if x1===x2 then 1 else cmp x1 x2;
cmp x y = str x < str y if atomp x && atomp y ;
cmp x y = ~(cmp y x) otherwise ;

// -------------------------------
// Generic Term Reording
// -------------------------------

span _ xs@[]      =  (xs, xs);
span p xs@(x:xs1) =  (x:ys,zs) when (ys,zs) = span p xs1 end if p x;
                  =  ([],xs) otherwise;

groupBy _  []           =  [];
groupBy eq (x:xs)       =  (x:ys) : (groupBy eq zs) when
                           (ys,zs) = span (eq x) xs end;

eqSig x y = sig x === sig y;
sigpart = groupBy eqSig;

sig x = sort cmp $ lsvars x;

// This is O(crazy) at the moment, I'll optimize later
mdeg a::int b::int = (a*b << 2);
graded a = if sum a == 1 
           then 1 + index a 1 
           else _graded a 0;

_graded []     _ = 1;
_graded (x:xs) n = (x * n << 2) + _graded xs (n+1);

reorder X = map sum
            $ sigpart 
            $ sort gorder
            $ lst X 
with
    sigx = sig X;
    isig e = [has e x | x = sigx];

    gorder a b = 
        graded (isig a) <
        graded (isig b);

    lst (a+b) = lst(a) + lst(b);
    lst a = [a] if varp x;
end;

lsvars X = members $ pick X with
    pick (x@_ y) = (pick x) + (pick y) if applp x;
                 = (pick y) otherwise;
    pick x = hset [x] if atomp x;
           = emptyhset otherwise;
end;

lsatoms X = members $ pick X with
    pick (x@_ y) = (pick x) + (pick y);
    pick x = hset [x] if atomp x && fixity x >= 30000;
           = emptyhset otherwise;
end;

// Univariate
uvarp x = #lsvars x == 1;
// Multivariate
mvarp x = ~uvarp x;

deepsame a b = same a b;

fullsimp X = eval $ reduce X with 
    0^x = 0 ;
    1^x = 1 ;
    x^0 = 1 ;
    x^1 = x ;

    (r^s)^w = r^(s*w) if numberp w ;
    (x*y)^w = (x^w)*(y^w) if numberp w ;

    0*x = 0 ;
    x*y = (base x) ^ ((exponent x) + (exponent y))
        if deepsame (base x) (base y) ;

    a*x*y = a * ( (base x) ^ ((exponent x) + (exponent y)) )
        if deepsame (base x) (base y) ;

    x*y = y*x if cmp y x ;

    x*y*z = x*z*y if cmp z y ;
    x*(y*z) = x*y*z;


    0+x = x ;
    a+b = ((constant a) + (constant b)) * (term a) 
        if deepsame (term a) (term b)
        && ~all numberp [a,b];

    a+b+c = a + (((constant b) + (constant c)) * (term b))
        if deepsame (term b) (term c)
        && ~all numberp [a,b];

    a+b = b+a
        if (cmp b a) && ~(sump a) ;
    a+b+c = a+c+b
        if cmp c b ;
    a+(b+c) = a+b+c ;

    x - y = x + (-1 * y) ;
    x % 1 = x;
    0 % _ = 0;
    x % y = x * (y^(-1)) if ~numberp y;
end;

applwhile pred f x = app (f x) (f $ f x) with
    app a b = a if pred a b;
            = app b (f b) otherwise;
end;

/*algebra_normal X = eval $*/
    /*applwhile (===) fullsimp rx*/
    /*when rx = reorder X end;*/

algebra_normal x = applwhile (===) fullsimp x;

simplify_trig X = reduce X with
    Sin 0 = 0;
    Cos 0 = 1;
    Sin (n::int*Pi) = 0;
    Cos (n::int*Pi) = (-1)^n;
    Cos (-x) = Cos x;
end;
