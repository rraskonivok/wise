/*
  Wise
  Copyright (C) 2010 Stephen Diehl <sdiehl@clarku.edu>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as
  published by the Free Software Foundation, either version 3 of the
  License, or (at your option) any later version.
*/

// References:
//  * Cohen J S. Computer Algebra and Symbolic Computation.
//  * Scheme code at https://github.com/dharmatech

namespace simplify;

private sump base exponent term constant;

cmp x y = x < y if numberp x && numberp y ;
cmp x y = 1 if numberp x && ~(numberp y) ;
cmp (a^b) (c^d) = if a === c then cmp b d else cmp a c ;
cmp a (b^c) = if a === b then cmp 1 c else cmp a b ;
cmp (a^b) c = if a === b then cmp b 1 else cmp a c ;
cmp (x1@_ y1) (x2@_ y2) = if x1===x2 then cmp y1 y2 else cmp x1 x2;
cmp (x1@_ y1) x2 = if x1===x2 then 0 else cmp x1 x2;
cmp x1 (x2@_ y2) = if x1===x2 then 1 else cmp x1 x2;
cmp x y = str x < str y if atomp x && atomp y ;
cmp x y = ~(cmp y x) otherwise ;

sump (x+y) = 1;
sump x = 0;

base (x^y) = x;
base x = x;

exponent (x^y) = y ;
exponent x = 1;

term (n*x) = x if numberp n ;
term ((x*y)*z) = (term (x*y)) * z ;
term (-x) = x;
term x = x ;

constant (n*x) = n if numberp n ;
constant ((x*y)*z) = (constant (x*y)) ;
constant (-x) = -1;
constant x = 1 ;

simplify_complex X = reduce X
with
    // Complex Addition
    (complex x y) + (complex u v) = complex (x+u) (y+v);
    - (complex x y) = complex (-x) (-y);

    // Complex Multiplication
    (complex a b) * (complex c d) = complex (a*c-b*d) (b*c+a*d);

    // Complex Division
    (complex a b) / (complex c d) = (complex ((a*c+b*d) / (c^2 + d^2)) ((b*c-a*d) / (c^2 + d^2)) )
end;


/*
    Automatic Simplification
   -------------------------
*/

simplify_multiplication = reduce
with
    0*x = 0 ;
    1*x = x ;
    x*y = (base x) ^ ((exponent x) + (exponent y)) if (base x) === (base y) ;
    a*x*y = a * ( (base x) ^ ((exponent x) + (exponent y)) ) if (base x) === (base y) ;
    x*y = y*x if cmp y x ;
    x*y*z = x*z*y if cmp z y ;
    x*(y*z) = x*y*z ;
    x*(-y) = (-x)*y ;
    -(k*x) = (-k)*x if numberp k;
end;

simplify_addition X = reduce X
with
    -(a*x) = (-a) * x if numberp a;
    0+x = x ;
    x+0 = x ;
    a+b = ( (constant a) + (constant b) ) * (term a) 
        if ((term a) === (term b)) and (~numberp a && ~numberp b) ;
    a+b+c = a + ((constant b) + (constant c)) * (term b) 
        if (term b) === (term c) ;
    /*a+b = b+a if (cmp b a) && ~(sump a) ;*/
    a+b+c = a+c+b if cmp c b ;
    a+(b+c) = a+b+c ;
    x-x = 0;
    (-x)+x = 0;
    (-x) + (-y) = -(x+y);
end;

simplify_power = reduce
with
    0^x = 0 if `(x ~= 0);
    1^x = 1 ;
    x^0 = 1 if `(x ~= 0);
    x^1 = x ;
    (r^s)^w = r^(s*w) if numberp w ;
    (x*y)^w = (x^w)*(y^w) if numberp w ;
end;

simplify_rational = reduce with
    x/x = 1;
    0/x = 0;
    x/1 = x;
    (-x)/y = -(x/y);
    1/(1/x) = x;
    x/(y/z) = (x*z)/y;
end;

rational_to_power = reduce with
    x/y = x*(y^(-1));
end;

rat_simp = reduce with
    1/(1/x) = x;
    0/x = 0;
    x/1 = x;
    x/(y/z) = (x*z)/y;
end;

// Reduce simple expressions involving 1 and 0
basic_simplify = reduce with
    x % y = 0 if numberp x && x == 0;
    x % y = 1 if numberp y && y == 1;
    x * y = 0 if (numberp x && x == 0) ||
                 (numberp y && y == 0);
    x * y = x if numberp y && y == 1;
    x * y = y if numberp x && x == 1;
    x + y = x if numberp y && y == 0;
    x + y = y if numberp x && x == 0;
    0^x = 0 if numberp x;
    x^0 = 1;
    x^1 = x;
    -(-x) = x;
    Exp x = exp x if numberp x;
    Sin x = sin x if numberp x;
    Cos x = cos x if numberp x;
end;

// Propogate an operator through an expression by applying it to
// the leaves of the expression tree and recursively upwards.
// At the moment only propogate through n={0,1,2,3} n-ary expressions.
propogate_thru rule expr = _rule (expr) with
    _rule (f@_ x y z) = rule $ f (_rule x) (_rule y) (_rule z) if ~(f === _rule);
    _rule (f@_ x y) = rule $ f (_rule x) (_rule y) if ~(f === _rule);
    _rule (f@_ x) = rule $ f (_rule x) if ~(f === _rule);
    _rule x = rule x;
end;

recursive_evalf = propogate_thru (evalf);
