/*
  Wise
  Copyright (C) 2010 Stephen Diehl <sdiehl@clarku.edu>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as
  published by the Free Software Foundation, either version 3 of the
  License, or (at your option) any later version.
*/

// References:
//  * Cohen J S. Computer Algebra and Symbolic Computation.
//  * Scheme code at https://github.com/dharmatech

simplify_negation X = reduce X with
    -(-x) = x;
    c::constant * (-x) = (-c) * x;
end;

namespace simplify;

/*
   -------------------------
    Automatic Simplification
   -------------------------
*/

// Reduce simple expressions involving 1 and 0
basic_simplify = reduce with
    x % y = 0 if numberp x && x == 0;
    x % y = x if numberp y && y == 1;
    x * y = 0 if (numberp x && x == 0) ||
                 (numberp y && y == 0);

    x * y = x if y `== 1;
    x * y = y if x `== 1;
    x * y = -x if y `== -1;
    x * y = -y if x `== -1;

    x + y = x if y `== 0;
    x + y = y if x `== 0;

    0^x = 0 if numberp x;
    x^0 = 1;
    x^1 = x;
    -(-x) = x;

    Sin 0 = 0;
    Cos 0 = 1;
    Exp 0 = 1;
end;

// Propogate an operator through an expression by applying it to
// the leaves of the expression tree and recursively upwards.
// At the moment only propogate through n={0,1,2,3} n-ary expressions.

propogate_thru rule expr = _rule (expr) with
    _rule (f@_ x y z) = rule $ f (_rule x) (_rule y) (_rule z) if ~(f === _rule);
    _rule (f@_ x y) = rule $ f (_rule x) (_rule y) if ~(f === _rule);
    _rule (f@_ x) = rule $ f (_rule x) if ~(f === _rule);
    _rule x = rule x;
end;

recursive_evalf = propogate_thru (evalf);

namespace;

// -------------------------------
// Term Properties
// -------------------------------

//  See: https://github.com/dharmatech

sump (x+y)     = 1 ;
sump x = 0 ;

base (x^y)     = x ;
base x         = x ;
exponent (x^y) = y ;
exponent x     = 1 ;

term (-x)      = term x;
term (n*x)     = x if numberp n ;
term (-n*x)    = x if numberp n;
term ((x*y)*z) = (term (x*y)) * z ;
term x         = x ;

constant (-n*x)    = -n if numberp n;
constant (n*x)     = n if numberp n ;
constant ((x*y)*z) = (constant (x*y)) ;
constant (-x)      = -1;
constant x         = 1 ;

cmp x y                 = x < y if numberp x && numberp y ;
cmp x y                 = 1 if numberp x && ~(numberp y) ;
cmp (a^b) (c^d)         = if a === c then cmp b d else cmp a c ;
cmp a (b^c)             = if a === b then cmp 1 c else cmp a b ;
cmp (a^b) c             = if a === b then cmp b 1 else cmp a c ;
cmp (x1@_ y1) (x2@_ y2) = if x1 === x2 then cmp y1 y2 else cmp x1 x2;
cmp (x1@_ y1) x2        = if x1 === x2 then 0 else cmp x1 x2;
cmp x1 (x2@_ y2)        = if x1 === x2 then 1 else cmp x1 x2;
cmp x y                 = str x < str y if atomp x && atomp y ;
cmp x y                 = ~(cmp y x) otherwise ;

// -------------------------------
// Graded Signatures
// -------------------------------

// This is O(crazy) at the moment, I'll optimize later
mdeg a::int b::int = (a*b << 2);
graded a = if sum a == 1
           then 1 + index a 1
           else _graded a 0;

_graded []     _ = 1;
_graded (x:xs) n = (x * n << 2) + _graded xs (n+1);

// -------------------------------
// Generic Term Reording
// -------------------------------

sigpart = groupBy eqSig;

asig x = sort cmp $ lsvars x;

simplesig X = _sig X with
    // Multiplication Expressions
    _sig (-a)                        = term a;
    _sig (a::symbolic * b::symbolic) = sort lexo [_sig a,_sig b];
    _sig (a           * b::symbolic) = term b;
    _sig (a::symbolic * b          ) = term a;

    // Exponential Expressions
    _sig (a::symbolic ^ n::number )  = (a,n);

    // Variables
    _sig a       = a if varp a;

    // Single variable functions
    _sig (f@_ x) = [f,x] if varp f;

    // Numeric terms
    _sig a::number = a;

    // Other terms -- assign unique hash
    _sig x       = hash x;
end;

hashsimpsig a b = hash (simplesig a) > hash (simplesig b);
eqSig x y = simplesig x === simplesig y;

// Flatten an expression and sort terms lexicographically

// Example:
// flatten_lex (+) (2*x+x+y+(2*x)); // [x,y,2*x,2*x]
flatten_lex op ex = sort lexo $ flatten op ex;
flatten_sig op ex = sort (hashsimpsig) $ flatten op ex;

reflatten op ex = foldl1 op $ flatten_lex op ex;

// Split toplevel addition and combine terms which have the same
// lexicographic order.
// Example:
// groupLikeTerms (x+y+y+z+z+x); // [[x,x],[y,y],[z,z]]
// reflowLiketerms (x+y+y+z+z+x); // [[x+x],[y+y],[z+z]]
groupLikeTerms op x = groupBy (eqSig) $ flatten_sig op x;
reflowLikeTerms op x = map (foldl1 op) $ groupLikeTerms op x;

compressLikeTerms op x = map combine (groupLikeTerms op x) with
    combine xs = (foldl1 (+) $ map constant xs) * term (xs ! 0) ;
end;

compressAddition X = sum $ compressLikeTerms (+) X;

reorder X = map sum
            $ sigpart
            $ sort gorder
            $ lst X
with
    sigx = asig X;
    isig e = [e has x | x = sigx];

    gorder a b =
        graded (isig a) <
        graded (isig b);

    lst (a+b) = lst(a) + lst(b);
    lst a = [a] if varp x;
end;

fullsimp X = reduce X with 
    0*x = 0;
    1*x = x;

    /*0^x = 0 ;*/
    /*1^x = 1 ;*/
    /*x^0 = 1 ;*/
    /*x^1 = x ;*/

    Nroot n x = x^(1%n);

    x^(1%n) * x^(1%n) = x;

    (r^s)^w = r^(s*w) if numberp w ;
    (x*y)^w = (x^w)*(y^w) if numberp w ;

    x*(-y) = -x*y;

    -(-x*y)  = (x*y);
    -(-x)  = x;

    x*y = (base x) ^ ((exponent x) + (exponent y))
        if (base x) ::=== (base y) ;

    a*x*y = a * ( (base x) ^ ((exponent x) + (exponent y)) )
        if (base x) ::=== (base y) ;

    x*y = y*x if cmp y x ;

    x*y*z = x*z*y if cmp z y ;
    x*(y*z) = x*y*z;

    0+x = x ;

    a+b = ((constant a) + (constant b)) * (term a)
        if (term a) ::=== (term b)
        && ::~ all numberp [a,b];

    /*a+b+c = a + (((constant b) + (constant c)) * (term b))*/
        /*if (term b) ::=== (term c)*/
        /*&& ~all numberp [b,c];*/

    a+b = b+a
        if (cmp b a) && ~(sump a) ;
    a+b+c = a+c+b
        if cmp c b ;
    a+(b+c) = a+b+c ;

    x - y = x + (-1 * y) ;
    x % 1 = x;
    0 % _ = 0;
    x % y = x * (y^(-1)) if ~numberp y;
end;

/*algebra_normal X = eval $*/
    /*applwhile (===) fullsimp rx*/
    /*when rx = reorder X end;*/

algebra_normal X = eval $ fullsimp . compressAddition $ X;

// Old Code
// Remove soon

simplify_trig X = reduce X with
    Sin 0 = 0;
    Cos 0 = 1;
    Sin (n::int*Pi) = 0;
    Cos (n::int*Pi) = (-1)^n;
    Cos (-x) = Cos x;
end;

simplify_complex X = reduce X
with
    // Complex Addition
    (complex x y) + (complex u v) = complex (x+u) (y+v);
    - (complex x y) = complex (-x) (-y);

    // Complex Multiplication
    (complex a b) * (complex c d) = complex (a*c-b*d) (b*c+a*d);

    // Complex Division
    (complex a b) / (complex c d) = (complex ((a*c+b*d) / (c^2 + d^2)) ((b*c-a*d) / (c^2 + d^2)) )
end;

/*rat_simp = reduce with*/
    /*1/(1/x) = x;*/
    /*0/x = 0;*/
    /*x/1 = x;*/
    /*x/(y/z) = (x*z)/y;*/
/*end;*/
