diffp (diff f x) = 1;
diffp _ = 0;

/*diff_normal X = reduce X*/
/*with*/
    /*diff x = 1;*/
    /*diff (c::int) x = 0;*/
    /*diff (c::int *u) x = c * (diff u x);*/

    /*// Power Rule*/
    /*diff (x^(n::int)) x = n * (x^(n-1)) if n > 0;*/
    /*diff (x^0) x = 0;*/
    /*diff (x^x) x = x^x * (1+ ln x);*/

    /*// Generalized Power Rule*/
    /*diff (f^g) x = f^g *( (diff g x) * (ln f) + (g/f) * (diff f x) );*/

    /*// Trigonometric functions*/
    /*diff (Sin x) x = Cos x;*/
    /*diff (Cos x) x = (-1)*Sin x;*/

    /*// Exponentials*/
    /*diff (Exp x) x = Exp x;*/

    /*// Logarithms*/
    /*diff (Ln x) x = 1/x if x ~= 0;*/
    /*diff (Ln (func@_ u)) x = (diff (func u) x)/(func x);*/

    /*// Linearity*/
    /*diff (u+v) x = (diff u x) + (diff v x);*/

    /*// Product Rule*/
    /*diff (u*v) x = (diff u x) * v + u * (diff v x);*/

    /*// Quotient rule*/
    /*diff (u/v) x = (((diff u x)*v) - (u*(diff v x)))/(v^2);*/

    /*// Chain rule*/
    /*diff (func@_ u) x = (diff (func u) u) * (diff u x) if ~(diffp (func u));*/
/*end;*/

ndiff f x n = foldl diff f (repeatn n x);

diff_both_sides (eq lhs rhs) = eq (diff lhs) (diff rhs);
diff_both_sides x = error "Must perform on relation.";

rulep (reduce_with x) = 1;
rulep _ = 0;

rules (reduce_with x) = x;

simp_integral = reduce with
    evals integrate (1/Sqrt(1+x^2)) x = Asinh x;
    evals integrate (1/Sqrt(x^2+1)) x = Asinh x;
    evals integrate x x = x^2;
    evals integrate (x^(n::int)) x = x^(n+1)/(n+1) if n ~= -1;
    evals integrate (x^(-1)) x = ln x;
    evals integrate (f+g) x = integrate f x + integrate g x;
end;

simp2_integral = extends simp_integral with
    evals integrate (x^(n::double)) x = x^(n+1)/(n+1) if n ~= -1;
end;
