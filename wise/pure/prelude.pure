export PURE_STACK=1024;

def extends x = x . reduce_with __locals__;

/* Evaluation */
prefix 1000 evalb; // Evaluation to boolean
prefix 1000 evali; // Evaluation to integer
prefix 1000 evalf; // Evaluation to float
prefix 1000 evals; // Evaluation to symbolic value

// For all x: i2p . p2i x = p2i . i2p x

// Hack to overcome the fact that we can't overload the internal
// `neg` function for integers
i2p x::double |
i2p x::int = x if x > 0;
           = Neg $ abs x if x < 0;

// Convert Infix to Prefix
i2p X = reduce X with
    x + y = add (i2p x) (i2p y);
    x - y = add (i2p x) (Neg $ i2p y);
    x * y = mul (i2p x) (i2p y);
    x / y = rational (i2p x) (i2p y);
    x ^ y = powr (i2p x) (i2p y);
    - x   = Neg (i2p x);
end;

// Convert Prefix to Infix
p2i X = reduce X with
    Num x         =    x   ;
    Neg x         =  - x   ;
    add x y       =  x + y ;
    mul x y       =  x * y ;
    rational x y  =  x / y ;
    powr x y      =  x ^ y ;

    // Disregard partial evaluations
    evalb x |
    evali x |
    evalf x |
    evals x = x;
end;

using dict;
subst x e = subst x (hdict e) with
  subst (x@_ y) e = (subst x e) (subst y e);
  subst x e = if member e x then e!x else x;
end;

def a::int/b::int       = rational a b;
def a::double/b::double = rational a b;
def a::int/b::double = rational a b;
def a::double/b::int = rational a b;

prefix 1001 `;

` expr = 1 if (expr === true);
       = 0 otherwise;

// The prototype operator is used to initialize rules dynamially
infixl 1001 -->;
prototype x y = x --> y;

// Extract the lhs/rhs of a prototype
lhs (l --> r) = str l;
rhs (l --> r) = str r;

// Create an instance of our prototype rule
instance proto = eval $ (lhs proto) + " = " + (rhs proto);
